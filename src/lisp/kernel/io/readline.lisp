
(defun readline:dont-analyze (text)
   nil)

(defun readline:extract-style-clause (index styles)
   (dolist (style styles)
      (when (and (>= index (caar style))
                 (<  index (cdar style)))
         (return (cdr style)))))

(defun readline:handle-line (stream prompt offset line styles)
   (vt100:jump-to-beginning-of-line stream)
   (vt100:clear-full-line stream)
   (princ prompt stream)
   (dotimes (i (length line))
      (let ((style-clause (readline:extract-style-clause (+ offset i) styles)))
         (vt100-styles:no-style stream)
         (dolist (style style-clause)
            (funcall style stream))
         (princ (aref line i) stream)))
   (vt100-styles:no-style stream))

(defun readline:join-lines (lines joiner)
   (let ((result '()))
      (dolist (line lines)
         (push line result)
         (push joiner result))
      (conversions:->string (apply #'append (mapcar #'conversions:->list (reverse result))))))

(defun readline:read-line (&key (stream (io:default-stream))
                                (text "")
                                (prompt "")
                                (analyze-function #'readline:dont-analyze)
                                (multi-line nil))
   (let* ((characters-left  '())
          (characters-right '())
          (lines-above      '())
          (lines-below      '())
          (saved-offset       0)
          (last-time (lmud.int:get-clock))
          (redo               t))
      (while t
         (let* ((now (lmud.int:get-clock))
                (line-count-above (length lines-above))
                (current-line-string (conversions:->string (append (reverse characters-left) characters-right)))
                (full-text-string (readline:join-lines (append (reverse lines-above) (list current-line-string) lines-below) "\n"))
                (analysis (funcall analyze-function full-text-string))
                (styles   (cdr (assoc :styles analysis)))
                (offset 0))
            (when (>= (- now last-time) 5000)
               (setq redo t))
            (when redo
               (vt100:move-up-by line-count-above stream)
               (dolist (line (reverse lines-above))
                  (readline:handle-line stream prompt offset line styles)
                  (incf offset (+ (length line) 1))
                  (terpri stream))
               (setq saved-offset offset))
            (readline:handle-line stream prompt saved-offset current-line-string styles)
            (when redo
               (incf offset (+ (length current-line-string) 1))
               (dolist (line lines-below)
                  (terpri stream)
                  (readline:handle-line stream prompt offset line styles)
                  (incf offset (+ (length line) 1)))
               (vt100:move-up-by (length lines-below) stream))
            (vt100:jump-to-line-pos (+ 1 (length prompt) (length characters-left)) stream)
            (setq redo nil)
            (setq last-time now)
            (let ((char (read-char stream)))
               (case char
                  ((#\Tab)       nil) ; Do nothing for now
                  ((#\Newline)   (if multi-line
                                     (if characters-right
                                        (progn (push (conversions:->string (reverse characters-left)) lines-above)
                                               (setf characters-left  '())
                                               (setq redo t))
                                        (if (and (null lines-below) (cdr (assoc :success analysis))) ; TODO: What if `:success` is not present?
                                            (return full-text-string)
                                            (progn (push current-line-string lines-above)
                                                   (setf characters-left  '())
                                                   (setf characters-right '())
                                                   (setq redo t))))
                                     (return full-text-string)))
                  ((#\Left)      (when characters-left  (push (pop characters-left)  characters-right)))
                  ((#\Right)     (when characters-right (push (pop characters-right) characters-left)))
                  ((#\Up)        (when lines-above (push current-line-string lines-below)
                                                   (setf characters-left  (reverse (conversions:->list (pop lines-above))))
                                                   (setf characters-right '())
                                                   (vt100:move-up-by 1 stream)
                                                   (setq redo t)))
                  ((#\Down)      (when lines-below (push current-line-string lines-above)
                                                   (setf characters-left  (reverse (conversions:->list (pop lines-below))))
                                                   (setf characters-right '())
                                                   (vt100:move-down-by 1 stream)
                                                   (setq redo t)))
                  ((#\Backspace) (if characters-left
                                     (pop characters-left)
                                     (when lines-above
                                        (setf characters-left (reverse (conversions:->list (pop lines-above))))
                                        (vt100:move-up-by 1 stream)
                                        (push "" lines-below) ; Avoid empty lines
                                        (setq redo t))))
                  ((#\Home)      (setf characters-right (append (reverse characters-left) characters-right))
                                 (setf characters-left  '()))
                  ((#\End)       (setf characters-left  (append (reverse characters-right) characters-left))
                                 (setf characters-right '()))
                  (t (push char characters-left))))))))
