
(defun readline:dont-analyze (text)
   nil)

(defun readline:extract-style-clause (index styles)
   (dolist (style styles)
      (when (and (>= index (caar style))
                 (<  index (cdar style)))
         (return (cdr style)))))

(defun readline:handle-line (stream prompt offset line styles)
   (princ prompt stream)
   (dotimes (i (length line))
      (let ((style-clause (readline:extract-style-clause i styles)))
         (vt100-styles:no-style stream)
         (dolist (style style-clause)
            (funcall style stream))
         (princ (aref line i) stream)))
   (vt100-styles:no-style stream))

(defun readline:read-line (&key (prompt "")
                                (stream (io:default-stream))
                                (analyze-function #'readline:dont-analyze)
                                (multi-line nil))
   (labels ()
      (let ((characters-left  '())
            (characters-right '())
            (lines-above      '())
            (lines-below      '()))
         (while t
            (let* ((line-count-above (length lines-above))
                   (current-line-string (conversions:->string (append (reverse characters-left) characters-right)))
                   (analysis (funcall analyze-function current-line-string))
                   (styles   (cdr (assoc :styles analysis))))
               (vt100:clear-full-line stream)
               (vt100:jump-to-beginning-of-line stream)
               (vt100:move-up-by line-count-above stream)
               (dolist (line lines-above)
                  (princ "<...>" stream)
                  (terpri stream))
               (readline:handle-line stream prompt 0 current-line-string styles)
               (vt100:jump-to-line-pos (+ 1 (length prompt) (length characters-left)) stream)
               (let ((char (read-char stream)))
                  (case char
                     ((#\Newline)   (if multi-line
                                        (if (cdr (assoc :success analysis)) ; TODO: What if `:success` is not present?
                                            (return current-line-string)
                                            (progn (push current-line-string lines-above)
                                                   (setf characters-left  '())
                                                   (setf characters-right '())))
                                        (return current-line-string)))
                     ((#\Left)      (when characters-left  (push (pop characters-left)  characters-right)))
                     ((#\Right)     (when characters-right (push (pop characters-right) characters-left)))
                     ((#\Backspace) (when characters-left  (pop characters-left)))
                     ((#\Home)      (setf characters-right (append (reverse characters-left) characters-right))
                                    (setf characters-left  '()))
                     ((#\End)       (setf characters-left  (append (reverse characters-right) characters-left))
                                    (setf characters-right '()))
                     (t (push char characters-left)))))))))
